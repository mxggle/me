{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/09/hello-world/"},{"title":"阿甘正传","text":"今天看了《阿甘正传》，这部电影其实早就想看了也早已下载到我的电脑上，但是总觉得一部好电影不能随随便便就看了，然后就一直存在我的磁盘里。。。 &ensp;&ensp;电影剧情比想象中的来的平淡，似乎没有开始，高潮，结束。更像是一个人的口述，也的确是如此，剧中主人公阿甘也同时扮演者这样一位有着各种经历的口述者，他只负责讲故事，至于从中得到什么，是你的事情。 这让我想起了余华的《活着》 这本书的叙事方式是以故事主人公徐富贵的自述方式进行。叙述朴素，不紧不慢，在读的过程中一度怀疑有流水账的倾向，平铺直叙。但看着看着我渐渐明白了作者的用意，就像作者所说的那样，“生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的看法。 其实《阿甘》也好《活着》也好，这两者的故事内容并不平淡，只是用平淡的方式叙述，反差下更引人深思。 阿甘生来白痴，却上了大学，在橄榄球球场上以一敌百，在越南战争中不怕空袭救战友，一玩乒乓球就精通，甚至因为自己心情不好出去跑步也掀起一场舆论。他的所做过的事，几乎没有一件是他想做的，或者是曾计划过去做的。正如阿甘所说的：人生就像一盒各式各样的巧克力，你永远不知道下一块会是哪种。 不过，他并不只是简单地接受生活带给他的各种巧克力，他听从妈妈的教训，珍妮的劝告，听从内心，做好每件事。当生活要拿走在他手里蓬勃发展的事业的时候。他没有过多的抱怨，而是放下这些羁绊继续向前。就像剧始剧末的那根羽毛一样，电影刚开始，羽毛被阿甘夹入故事书，电影结束，阿甘打开书本，那根羽毛，轻轻的，风一吹转几下就走了。人不能一直被自己的抱怨耽误，被自己的过去拖累。 看了一篇关于《阿甘正传》的影评，上面提到“无为”。我对这种高深的思想没有研究，引用一下来自百度对“无为”的解释。 无为指经过有为的思考，以潮流的判断做出顺势而为的行为，即顺应自然的变化规律，使事物保持其天然的本性而不人为做作，从而达到“无为而无不为”的境界。 “从而达到“无为而无不为”的境界”，听起来很耐人寻味，那个味到底是什么，得慢慢体会，即便是寻到了，想做到，难上加难。单从我自己来说，我应该属于那种容易被自己过去拖累，容易抱怨的人，只是程度没有那么深，可江山易改本性难移，很多观念，很多习惯，不是说改就能改的，即使是死板的程序，在进行更新迭代的时候也会出各种各样的BUG呢。 所以，想那么多有什么用呢，像阿甘一样，just running!","link":"/2019/09/09/test/"},{"title":"小知识点 - 我理解的javascript的LHS和RHS","text":"最近在看Kyle Simpson的 You Dont Know JS第一章作用域讲到了LHS和RHS。 JS引擎在作用域内查找一个变量的时候会有两种查询方式，LHS（Left-hand Side）查询和 RHS（Right-hand Side）查询。 如果为了对称美的话，可以这么解释： 当一个变量出现在赋值操作的左手边时，会进行 LHS 查询 当一个变量出现在赋值操作的右手边时，会进行 RHS 查询 但如果为了方便理解的话，我觉得这个解释差点味道，文中也说这个解释不是特别准确，特别是对RHS的解释，当涉及到代码的时候，在不理解这两个查询是什么意思是的情况下，容易让人摸不着头脑。 说一下我是怎么理解的： LHS查询，可以把它理解为 容器查询，什么意思呢，比如说 var a = 0 赋值语句。引擎执行到这段代码的时候需要查找a这个变量并把0赋值给它。这个查询不需要知道a的值是什么，只需要找到a就行（也就是所谓的容器）然后在容器中放入0 RHS查询，可以把它理解为 值查询，如果你理解了上面所说的LHS查询的话，那么这个就很好理解了。比如：console.log(a)，引擎在执行到这段代码的时候，需要通过RHS查询获取一下a的值，然后将它的值打印出来 补充在变量还没有被声明（在所有被查询的 作用域 中都没找到）的情况下，这两种类型的查询的行为不同。（这里我直接copy了原文）。 如果 RHS 查询在嵌套的 作用域 的任何地方都找不到一个值，这会导致 引擎 抛出一个 ReferenceError。必须要注意的是这个错误的类型是 ReferenceError。 相比之下，如果 引擎 在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 作用域 将会在 全局作用域中 创建一个同名的新变量，并把它交还给 引擎。 在 ES5 中被加入的“Strict模式”[^note-strictmode]，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 作用域 的变量交回给 LHS 查询，并且类似于 RHS 的情况, 引擎 将抛出一个 ReferenceError","link":"/2019/09/11/小知识点-我理解的javascript的LHS和RHS/"}],"tags":[{"name":"观后感","slug":"观后感","link":"/tags/观后感/"},{"name":"Javscript 小知识","slug":"Javscript-小知识","link":"/tags/Javscript-小知识/"}],"categories":[{"name":"电影","slug":"电影","link":"/categories/电影/"}]}