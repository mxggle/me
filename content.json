{"pages":[{"title":"","text":"我是个前端 技术栈基础Javascript, TypeScript, Node, MongoDb, MySql框架React, Vue, Nest, TypeORM其他Docker, Nginx, Vim 可以关注一下我的Twitter 喜欢摄影，入了尼康坑可以关注一下我的Instagram 练习吉他中 程序员也需要带点文艺气息 喜欢看美剧权力的游戏 Game Of Trones 绝命律师 Better call saul 怪奇物语 Stranger Things 越狱 Prison Break 迷失 Lost 绝命毒师 Break Bad 无耻之徒 Shameless 哥谭镇 Gotham 纸钞屋 Money Heist（好吧它是西剧） 当然还有 硅谷 Silicon Valley 关于博客就是记录一下自己学到的，想分享的东西。我想知道十年后我打开自己的博客网站，看自己的文字，会觉得自己的现在是什么样的一个人？处于一个什么样的阶段？行业技术处于什么样的阶段？还能否听懂我所分享的东西？","link":"/about/index.html"}],"posts":[{"title":"两周的Vim使用感受","text":"先列一下我在使用Vim前对于它的刻板印象 命令很多, 使用vim, 需要记忆大量的命令 现在像VSCode, webStrom 这些编辑器, IDE 生态非常丰富, 使用Vim 有点”old school”, 自动补全定义跳转这些功能搞起来也没前者方便 我平时喜欢逛逛油管, 在上面总能看到一些大佬撸代码的视频, 或者敲代码的crash course . 关注的几个博主比如大名鼎鼎、破解iPhone手机的George Hotz, 软件顾问Ben Award 都还在使用vim. 在他们手里那个光标像个带了个跳刀的火猫在代码间穿梭自如. 我忍不住打开vim 敲了几下,MD我的光标简直像个小脑发育不全的智障. 羡慕之余, 我学起了Vim, 现在已经用了两个礼拜了, 基本离不开它了，很多命令已经熟记在心(其实两天就够了), 只差多练提速了 网上vim 命令大全一搜一大堆, 我这里就只记录一下常用的几个命令, 有了以下几个, 基本上就能非常愉快地使用vim了 教程开始模式 正常模式(Normal Mode) 大部分命令都在这个模式发出(按esc退出其他模式进入normal模式) 插入模式(Insert Mode) 可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。 可视模式(Visual Mode)：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式. 替换模式(Replace Mode)：正常模式下，按R进入。 命令模式(Command Mode): 可输入多种命令, 比如全局搜索, 正则替换等, 在正常模式输入:进入 上下左右移动,没使用vim之前总觉得vim为啥需要把移动按键放在这个位置, 也没有具体的意思, 用多了才知道,这个位置可比键盘上的上下左右舒服多了.现在我没事就喜欢JKJKJK地敲 h 左 j 上 k 下 l 右 单词移动通过下面三个命令, 在单词与单词之间移动起来就非常畅通无阻了 w 光标移动到下一个单词的词首 b 向前移动光标，移动到前一个单词的词首 e 光标移动到下一个单词的词尾 块移动通过以下几个命令, 光标就学会长距离的闪现了 0 移动到本行第一个字符上 ^ 移动到本行第一个非空白字符(或者结合0 和 w) $ 移动到行尾 G 移动到文件末尾行 gg 移动到文件首行 ) 光标移动到下一句 ( 光标移动到上一句 { 向上移动一个段落 } 向下移动一个段落 复杂移动通过下面的命令, 光标就学会了精确的传送,想去哪去哪 f[字符]: 把光标移到同一行的指定字符处 t[字符]: 把光标移到同一行的下一个c字符前 插入命令 i 在当前位置前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 删除 dd 删除当前行 D 删除当前字符至行尾。D=d$ [n]x 删除光标起1(n)个字符 d[n]w 删除光标起1(n)个词 改写 c[n]w 改写光标后1(n)个词。 c[n]l 改写光标后n个字母。 r 替换光标处的字符 R 进入替换模式，按esc回到正常模式。 撤销与重做 [n]u 取消1(n)个改动。 ctrl + r 重做最后的改动(和 u 相反) U 取消当前行中所有的改动。 注意到上面的d[n]w 和c[n]w, 会发现其实是用删除命令d 结合了 移动命令中的 w, vim 中还有很多类似的结合(比如dfc), 包括命令的大小写区分, 可以在敲代码的时候亲自尝试一下, 用一次就记住了, 基本没有什么记忆成本. 复制粘贴 y: 复制在可视模式下选中的文本(或者结合之前所get到的规律, 试试 yw) yy: 复制整行(可以结合数字 2yy就是复制两行) p : 粘贴之前所复制(y) 的内容 我现在习惯于 行选择模式V + 移动命令 + y 复制大段大段的文字. 好了, 其实说完复制粘贴就够了, 懂得都懂。 将Vim视作工具使用vim和现在的各种IDE并不互斥,开发过程中完全可以两者结合一起使用, 把Vim当作一个提高你编码效率的工具 结合的方式很简单, 如果是VScode 安装Vim插件即可, 类似Webstorm,Idea 这些可以安装IdeaVim. 作为中国程序员, 推荐安装 IdeaVimIdeaExtension(WebStorm)插件, 这样在切换成normal模式时, 它会自动帮你将输入法更改为英文输入法, 从而避免中文输入法的干扰 (切换回插入模式时也会自动将输入法改回之前设定) 最后分享两点感受 像Vim 这些东西,只不过是工具而已, 只要能提高效率和体验, 怎么用见仁见智, 不要为Vim而Vim 学习是个积累的过程, 避免一口吃成胖子的心态, 像Vim, 刚开始可能只能记住简单的几个命令, 但在coding过程中, 只要不断地使用, 所掌握的命令肯定会越来越多, 也会越来越熟练(我就在这么积累中) 参考内容Vim Cheat Sheet Vim Editor Modes Explained The VIM Tutor 史上最全的Vim命令","link":"/2020/12/20/两周的Vim使用感受/"},{"title":"在Chrome查看持续连接和非持续连接","text":"浏览器输入 URL 后发生了什么？这个问题已经被问坏了，答案也被背坏了，什么DNS解析， 三次握手建立TCP连接等等。这篇文章只浅谈一下上面这个过程的一小部分，即客户端和服务器之间建立连接过程中所涉及到的持续连接(persistent connection)和非持续连接(non-persistent connection)这两个概念。 简介那什么是持续连接呢？这里我直接从 维基百科 上抄了下来 HTTP persistent connection, also called HTTP keep-alive, or HTTP connection reuse, is the idea of using a single TCP connection to send and receive multiple HTTP requests/responses, as opposed to opening a new connection for every single request/response pair. 意思很简单，在持续连接下，会对同一个TCP连接进行复用，即一个TCP连接可以在一定时间内处理多个请求/响应对，而非持续连接下，会为每一个请求/响应对 都建立一个TCP连接。 很明显持续连接比非持续连接更绿色环保。 相比之下非持续连接这种方式有不少缺点，比如 每建立一个TCP连接都会占用客户端和服务器上的一定资源， 非持续连接为每个请求都建立一个连接的方式无疑增加更多资源的占用 每个请求都要经过三次握手，无疑增加请求延迟 而持续连接的优势在RFC有就有提到 在Chrome中观察从HTTP/1.1开始，默认都是使用持续连接。可以在Chrome Dev tools的Network Tab看到， 为了方便观察，可以用https://badssl.com/ 可以先在这个网站进行测试，该网站发送的都是HTTP/1.1的请求。 如图的 Connection ID 列里面每一个ID就代表了一个TCP连接（如果没有这列的话右击表头勾上Connection ID 这一项） Chrome浏览器限制最多同时打开6个TCP链接，在HTTP/1.1协议下，多个请求会显示同一个Connection ID 。 如上图中的 ID 259198，可以在Waterfall 这一列中观察到，同一个ID下的请求只有第一个请求会去建立TCP连接，且这个ID下每个请求都是等待上个请求完成之后再进行请求（注意: Chrome 会对TCP连接进行缓存，所以如果在短时间内重新刷新页面会发现第一个请求也没有进行TCP连接 https://stackoverflow.com/questions/37170812/force-chrome-to-close-re-open-all-tcp-tls-connections-when-profiling-with-the-ne 而对于HTTP/2.0来说，由于支持多路复用(multiplexing)，同一个TCP连接下可以同时发送多个请求.可以在下图中看到在ID 266055 下，多个请求基本上是同时发出的","link":"/2020/12/30/在Chrome查看持续连接和非持续连接/"},{"title":"我的终端快捷命令配置技巧","text":"这篇文章和把敲代码过程中的琐碎操作交给肌肉记忆这篇文章类似，分享一下我提高效率的技巧。 我用的终端app是iTerm2，如果你是程序员，并且用的是Mac，那么iTerm2应该都了解过。这里就不介绍它了。iTerm2的配置文件路径（其他终端自己找对应配置文件）1~/.zshrc 我常用的快捷命令配置主要是两种： alias 脚本函数 我的alias配置如下 1234567891011121314151617181920 # 快捷命令alias cls='clear'alias ll='ls -l'alias la='ls -a'alias vi='vim'alias dma='docker-machine'alias py='python3'alias rn='react-native'alias rna='react-native run-android'alias gitcgmuggle='git config --local user.name muggle &amp;&amp; git config --local user.email muggle6594@gmail.com'# App安装开关任何涞源alias anywhereon='sudo spctl --master-disable'alias anywhereoff='sudo spctl --master-enable'# 快捷进入目录alias pj='cd ~/Work/projects'alias rt='cd ~/Work/test/react'alias blog='cd ~/Work/projects/myblog'# serversalias vps='/Users/szy/myshells/myvps.sh' 上面的vpsalias是我原来用来科学上网的服务器，这里我是引入了外部的脚本文件: 12345678910111213 #!/usr/bin/expect -fset user rootset host **.**.**.**set port ***set password **************set timeout -1spawn ssh $user@$host -p $portexpect \"*password:*\"send \"$password\\r\"interactexpect eof 我的脚本函数配置如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 关闭终端代理function proxyoff()&#123; unset http_proxy unset https_proxy unset all_proxy curl ip.gs echo -e \"已关闭代理\"&#125;# 开启终端代理function proxyon() &#123; export https_proxy=http://127.0.0.1:7890; export http_proxy=http://127.0.0.1:7890; export all_proxy=socks5://127.0.0.1:7891 env | grep -i proxy curl ip.gs echo -e \"已开启代理\"&#125;# 开启端口转发function ptfon()&#123; echo \" rdr pass inet proto tcp from any to any port 80 -&gt; 127.0.0.1 port $1\" | sudo pfctl -ef - if [ $? -ne 0 ] then echo \"端口未转发\" else echo \"👉 已将 $1 端口转发至 80\" fi &#125;# 关闭端口转发function ptfoff()&#123; sudo pfctl -F all -f /etc/pf.conf portf_list echo \"👉 已取消端口转发\"&#125;function ptfls()&#123; sudo pfctl -s nat&#125;function rni()&#123; # xcrun simctl list devices if \"$1\" then react-native run-ios --simulator 'iPhone 7 Plus' else react-native run-ios fi&#125; 我上面的一些配置都是我经常使用的一些。脚本函数那一块，存在错误和不完善的地方，等之后遇到新的痛点了统一修复吧。虽然快捷命令啥的用起来很爽，但是我在配置快捷命令的时候还是一个原则的即偷可以偷的懒, 作为一个程序员，很多命令肯定需要熟记在心的，不能有了这个偷懒的方法，就把所有的命令都给配置成了快捷命令，可能配置完后用的时候爽了，但如果换了台电脑。。。或者某一天公司服务器服务突然崩了，你连接上服务器才发现自己只会打快捷命令。。。。 最后，如果你其他快捷配置，或者其他玩法，请务必分享给我。","link":"/2019/10/19/我的终端快捷命令配置技巧/"},{"title":"把敲代码过程中的琐碎操作交给肌肉记忆","text":"在敲代码的过程中，肯定会有不少琐碎的操作，这些操作或多或少占用着我们大脑的进程，但其实很多操作可以让我们的肌肉记忆去完成它。 比如在各个应用之间来回切换，当打开的应用超过3个以上之后，鼠标或者Tab键可能就忙不过来了，关键切换之前还得先找到对应的应用（换句话说就是在切换应用的时候额外占用了眼睛的进程） 这篇文章分享一下我是怎么把切换应用的操作交给肌肉记忆的，用到了下面两个App（macOS） Karabiner-Elements (以下用KE代之) Keyboard Maestro (以下用KM代之) Thor Karabiner-Elements这是一个MacOs下强大的改键应用。键盘改键一部分原因是以前的习惯导致需要把一些键映射成其他键（比如ctrl和fn）。这里我主要用来改一些基本用不到的键。比如键盘中的右command,右option。这些键从电脑的入手到用废弃，基本按不了几下，按不了几下也就忍了，可它们占据了键盘中非常好的位置，这就有点占着茅坑不拉屎的意思了，所以为啥不改了它呢？下面，我以把右commnad改为F19为例，说一下改键流程(F19叫做超级键hyper key是command+shift+option+control键的组合)。 首先安装一下app,可以通过官网，或者homebrew1brew install karabiner-elements 安装完毕后打开这个网站。 可以看到这里列出了很多的改键预设，你可以找一个你喜欢的，或者差不多的点击import，这里选择Change caps_lock key(rev4)。如果你已经安装好了KE，点击后会自动提示是否打开KE，点击打开。 打开后，点击import.接着会进入这个界面，随便选一个enable就成，反正最终都是要改的。操作完之后，复杂改键（complex modifications）Tab栏下的Rules就会多一条。 这里默认把caps_lock改了，其实也挺好的。caps_lock比较容易够到, 而且用的小拇指去按，所以非常适合配合其他键来实现组合键。但是毕竟本身用来切换大小写，不太好单独当作一个自定义功能键使用（KE中可以配置改键在单独按下还是和其它键组合的时候生效）。 接下来讲一下怎么把这个键改成右command。 打开下面这个文件。1~/.config/karabiner/karabiner.json 这个文件是KE的配置文件，其实上面的一系列操作的结果最终会写入这个配置文件中。注意到很长的那个description了吗，就是我们刚才操作的结果。你可以按照上面的步骤多引入几个看一看，看完然后差不多就明白配置文件的语法了。这里按照我们的要求，只要把caps_lock改为right_command即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; \"global\": &#123; \"check_for_updates_on_startup\": true, \"show_in_menu_bar\": true, \"show_profile_name_in_menu_bar\": false &#125;, \"profiles\": [ &#123; \"complex_modifications\": &#123; \"parameters\": &#123; \"basic.simultaneous_threshold_milliseconds\": 50, \"basic.to_delayed_action_delay_milliseconds\": 500, \"basic.to_if_alone_timeout_milliseconds\": 1000, \"basic.to_if_held_down_threshold_milliseconds\": 500 &#125;, \"rules\": [ &#123; \"description\": \"Change caps_lock key to command+control+option+shift. (Post f19 key when pressed alone)\", \"manipulators\": [ &#123; \"from\": &#123; \"key_code\": \"caps_lock\", // 改为right_command \"modifiers\": &#123; \"optional\": [ \"any\" ] &#125; &#125;, \"to\": [ &#123; \"key_code\": \"left_shift\", \"modifiers\": [ \"left_command\", \"left_control\", \"left_option\" ] &#125; ], \"to_if_alone\": [ &#123; \"key_code\": \"f19\" &#125; ], \"type\": \"basic\" &#125; ] &#125; ] &#125;, \"devices\": [], \"name\": \"Default profile\", \"selected\": true, \"simple_modifications\": [], \"virtual_hid_keyboard\": &#123; \"country_code\": 0 &#125; &#125; ]&#125; 改完左command，接下来就可以依样画葫芦，改右option，右shift，甚至左option。 到这里改键就完成了。之后就是给你改好的键分配命令了，这就看你的需求了，比如我把右command给了Alfred, 右option给了iTerm2。绑定完之后就可以愉快一键激活App了。 这里有个问题，不是所有app都如Alfred一样，提供了设置快捷键激活窗口的功能。这就需要用到下面的app协助了 Thor这个使用起来很简单。选择app，然后绑定按键，绑定后的app就能通过快捷键启动、快捷键激活窗口。 改的过程中你可能又会遇到一个问题，提供快捷键激活功能的软件或者Thor，都不能直接绑定option这类的修饰类按键（必须要和其他非修饰类键组合）。解决方法就是Thor + KE配合，也就是本文的例子右command的改法（one-to-many）。 这个app非常轻量好用，不过有个问题，我的手比较贱。没事就喜欢乱敲快捷键，所以老是误打开不想要的软件。 因为这个原因我换成了下面这个 Keyboard Maestro Keyboard Maestr 是macOS的一个自动化软件，他的功能非常多，本文只用它来绑定App快捷键 可以看到这里右侧的action中，快捷键激活App可以写条件分枝。我这里写的是，如果当前app在运行，就激活App, 否则就不做任何操作，完美解决了我手贱的毛病 具体用法我就不多做介绍了，有点类似Alfred的workflow, 可以用各种action，支持好多种语言的script。这里我就抛砖引玉提供一下我自己目前在用的快捷键绑定marcos，直接导入即可。 链接:https://pan.baidu.com/s/1yNW8tP-En3S138s-3Gf04w 密码:761o 还有社区提供的一些资源，相信看完几个Marco，就能依样画葫芦了 https://wiki.keyboardmaestro.com/Macro_Library#:~:text=Keyboard%20Maestro%20provides%20an%20extensive,to%20import%20into%20your%20library. https://forum.keyboardmaestro.com/t/best-macro-list/4118 总结最后一个问题，就是记忆快捷键，我和朋友安利这个的时候都嫌要记忆快捷键麻烦 我基本上为我常用的app都加上了快捷键，大概十来个左右，都是工作过程中因为某些操作不顺手而慢慢加上的，所以并没有什么记快捷键的成本。一旦改键+绑定工作完成，并且配置的快捷键也形成肌肉记忆，敲代码的时候，就可以随心所欲地在各个App之间来回切换了。换句话说你大脑的一个指令，通过快捷键辅助可以直接下达到手指，不用再麻烦大脑其他部位了。 其实和记忆vim的命令一样，这种东西不是一下子全部记住之后再去使用的，而是在工作中慢慢地用，自然而然掌握的，过程中可能需要小小地迈出自己的舒适圈。 最后推荐以下耗子叔的 简明 VIM 练级攻略","link":"/2019/10/18/把敲代码过程中的琐碎操作交给肌肉记忆/"},{"title":"翻译-五个高级React模式","text":"原文： https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6 5种高级React模式概述了5种现代高级React模式，包括集成代码、优点和缺点，以及在公共库中的具体用法。 像每个React开发者一样，你可能已经问过自己以下问题之一。 我如何建立一个可重复使用的组件以适应不同的使用情况？ 我如何建立一个具有简单API的组件，使其易于使用？ 我如何建立一个在用户界面和功能方面可扩展的组件？ 这些反复出现的问题催生了整个React社区的一些高级模式的出现 在这篇文章中，我们将看到5种不同模式的概述。为了便于比较，我们将对所有这些模式使用一个相同的结构。 我们将从一个小的介绍开始，然后是一个真实的代码例子（基于同一个简单的Counter组件）。 所有的源代码都可以在这个github仓库中获得：https://github.com/alex83130/advanced-react-patterns。 我们将列出优点和缺点，然后在一个名为 “标准 “的部分中定义两个因素。 反转控制: 你的组件给用户提供的灵活性和控制等级 实施的复杂性: 你和用户实现该模式的难度。 最后，我们将找一些公共库在生产环境中使用该模式的例子 在这篇文章中，我们将考虑一个React开发者（你）为其他开发者构建一个组件的情况。因此，”用户 “这个角色直接指的是这些开发者（而不是使用你的网站/应用程序的最终用户）。 1. 复合组件模式（Compound Components Pattern）这种模式允许创建富有表现力和声明性的组件，避免非必要的prop drilling。如果你想让你的组件更有可塑性，有更好的关注点分离和易理解的API，你应该考虑使用这种模式。 ExampleGithub: https://github.com/alex83130/advanced-react-patterns/tree/main/src/patterns/compound-component 12345678910111213141516171819import React from \"react\";import &#123; Counter &#125; from \"./Counter\";function Usage() &#123; const handleChangeCounter = (count) =&gt; &#123; console.log(\"count\", count); &#125;; return ( &lt;Counter onChange=&#123;handleChangeCounter&#125;&gt; &lt;Counter.Decrement icon=\"minus\" /&gt; &lt;Counter.Label&gt;Counter&lt;/Counter.Label&gt; &lt;Counter.Count max=&#123;10&#125; /&gt; &lt;Counter.Increment icon=\"plus\" /&gt; &lt;/Counter&gt; );&#125;export &#123; Usage &#125;; 优点 减少了API的复杂性：与其把所有的props都塞进一个巨大的父组件中，然后再把这些props钻到子UI组件中，不如在这里把每个props都连接到各自最有意义的子组件上。 灵活的标记结构：你的组件有很大的UI灵活性，允许从一个单一的组件创建各种情况。例如，用户可以改变子组件的顺序或定义哪个组件应该被显示。 关注点分离：大部分的逻辑都包含在主Counter组件中，然后用React.Context来分享所有子组件的状态和事件处理。我们得到了一个明确的责任划分。 缺点 太高的UI灵活性：拥有灵活性的同时，也有可能引发意想不到的行为（把一个不需要的组件的子组件放进去，把子组件的顺序弄乱，忘记包含一个必须的子组件） 根据你想要用户如何使用你的组件，你可能不希望有那么多的灵活性。 更重的JSX：应用这种模式会增加JSX行的数量，特别是当你使用像ESLint这样的代码检测工具或类似Prettier这样的代码格式化工具时在单个组件的规模上，这似乎不是什么大问题，但当你从全局来看时，肯定会产生巨大的差异。 标准 反转控制：1/4 实施的复杂性：1/4 使用此模式的公共库 React Bootstrap Reach UI 2. 受控属性模式这种模式将你的组件转变为一个受控组件。外部状态作为 “单一事实源 “被消耗，允许用户插入自定义逻辑，修改默认组件的行为。 例子Github: https://github.com/alex83130/advanced-react-patterns/tree/main/src/patterns/control-props 1234567891011121314151617181920import React, &#123; useState &#125; from \"react\";import &#123; Counter &#125; from \"./Counter\";function Usage() &#123; const [count, setCount] = useState(0); const handleChangeCounter = (newCount) =&gt; &#123; setCount(newCount); &#125;; return ( &lt;Counter value=&#123;count&#125; onChange=&#123;handleChangeCounter&#125;&gt; &lt;Counter.Decrement icon=&#123;\"minus\"&#125; /&gt; &lt;Counter.Label&gt;Counter&lt;/Counter.Label&gt; &lt;Counter.Count max=&#123;10&#125; /&gt; &lt;Counter.Increment icon=&#123;\"plus\"&#125; /&gt; &lt;/Counter&gt; );&#125;export &#123; Usage &#125;; 优点 给予更多的控制：由于主状态暴露在你的组件之外，用户可以控制它，因此可以直接影响你的组件。 缺点 实施的复杂性: 之前，在一个地方（JSX）的一个集成就足以使你的组件工作。现在，它将分散在3个不同的地方（JSX / useState / handleChange）。 标准 反转控制：2/4 实施的复杂性：1/4 使用此模式的公共库 Material UI 3. 自定义钩子模式让我们在 “控制反转 “中更进一步：主要的逻辑现在被转移到一个自定义的钩子中。这个钩子可以被用户访问，并且暴露了几个内部逻辑（状态、处理程序），允许他对你的组件有更好的控制。 例子Github: https://github.com/alex83130/advanced-react-patterns/tree/main/src/patterns/custom-hooks 123456789101112131415161718192021222324252627282930313233343536373839import React from \"react\";import &#123; Counter &#125; from \"./Counter\";import &#123; useCounter &#125; from \"./useCounter\";function Usage() &#123; const &#123; count, handleIncrement, handleDecrement &#125; = useCounter(0); const MAX_COUNT = 10; const handleClickIncrement = () =&gt; &#123; //Put your custom logic if (count &lt; MAX_COUNT) &#123; handleIncrement(); &#125; &#125;; return ( &lt;&gt; &lt;Counter value=&#123;count&#125;&gt; &lt;Counter.Decrement icon=&#123;\"minus\"&#125; onClick=&#123;handleDecrement&#125; disabled=&#123;count === 0&#125; /&gt; &lt;Counter.Label&gt;Counter&lt;/Counter.Label&gt; &lt;Counter.Count /&gt; &lt;Counter.Increment icon=&#123;\"plus\"&#125; onClick=&#123;handleClickIncrement&#125; disabled=&#123;count === MAX_COUNT&#125; /&gt; &lt;/Counter&gt; &lt;button onClick=&#123;handleClickIncrement&#125; disabled=&#123;count === MAX_COUNT&#125;&gt; Custom increment btn 1 &lt;/button&gt; &lt;/&gt; );&#125;export &#123; Usage &#125;; 优点 给予更多的控制: 用户可以在钩子和JSX元素之间插入自己的逻辑，允许他修改默认组件的行为。 缺点 实施的复杂性：由于逻辑部分与渲染部分是分开的，所以必须由用户将两者联系起来。要正确地实现它，需要对你的组件的工作方式有一个很好的理解。 标准 反转控制：2/4 实施的复杂性：2/4 使用此模式的公共库 React table React hook form 4. Props getter 模式自定义钩子模式提供了很好的控制，但也使你的组件更难集成，因为用户必须处理大量的组件本地钩子的props，并在他那边重新创建逻辑。Props Getters模式试图掩盖这种复杂性。我们不暴露本地props，而是提供一个props getters 的短名单。一个getter是一个返回许多props的函数，它有一个有意义的名字，允许用户自然地将其链接到正确的JSX元素。 优点 易用性：提供一种简单的方式来整合你的组件，复杂性被隐藏起来，用户只需将正确的getter连接到正确的JSX元素。 灵活性： 用户仍然有可能重载getters中的props，以适应他的具体情况。 缺点 缺少可见性： getters 带来的抽象性使你的组件更容易集成，但也更不透明和 “魔法”。为了正确地覆盖你的组件，用户必须知道getters所暴露的props列表，以及如果其中一个props被改变所带来的内部逻辑影响。 标准 反转控制：3/4 集成的复杂性：3/4 使用此模式的公共库 React table Downshift 5. State reducer 模式在控制的反转方面是最先进的模式。它为用户提供了一种先进的方式来改变你的组件的内部操作方式。 代码类似于自定义钩子模式，但除此之外，用户还定义了一个被传递给钩子的reducer。这个reducer将重载你的组件的任何内部动作。 例子Github: https://github.com/alex83130/advanced-react-patterns/tree/main/src/patterns/state-reducer 在这个例子中，我们结合了State reducer模式和Custom hook模式，但是你也可以把它和Compound components模式一起使用，直接把reducer传递给主组件Counter。 优点 给予更多的控制：在最复杂的情况下，使用state reducers是把控制权留给用户的最好方法。你所有的内部组件的动作现在都可以从外部访问，并且可以被重写。 缺点 实施的复杂性：这种模式的实现肯定是最复杂的，无论是对你还是对用户。 缺少可见性：由于任何reducer的动作都可以被改变，因此需要很好地理解组件的内部逻辑。 标准 反转控制：4/4 集成的复杂性：4/4 使用此模式的公共库 Downshift 总结通过这5个高级React模式，我们看到了利用 “控制反转 “概念的不同方式。它们给你提供了一个强大的方法来创建灵活和适应性强的组件。然而，我们都知道这句著名的谚语：”能力越大责任越大”，你越是把控制权转移给用户，你的组件就越是远离 “即插即用 “的思维方式。作为一个开发者，你的角色是选择正确的模式来对应正确的需求。为了帮助你完成这项任务，下面的图表根据 “集成的复杂性 “和 “控制反转 “这两个因素对所有这些模式进行了分类。 这篇文章的灵感主要来自于Kent C. Dodds的惊人工作如果你有兴趣了解更多关于每个模式的信息，请看他的博客。我希望你觉得这篇文章有用。谢谢你的阅读。 更多内容请见 plainenglish.io","link":"/2021/06/02/翻译-五个高级React模式/"}],"tags":[{"name":"网络","slug":"网络","link":"/tags/网络/"},{"name":"调试","slug":"调试","link":"/tags/调试/"},{"name":"性能","slug":"性能","link":"/tags/性能/"},{"name":"效率","slug":"效率","link":"/tags/效率/"},{"name":"Mac使用技巧","slug":"Mac使用技巧","link":"/tags/Mac使用技巧/"},{"name":"终端","slug":"终端","link":"/tags/终端/"},{"name":"翻译","slug":"翻译","link":"/tags/翻译/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[]}